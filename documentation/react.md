# React

## Классы/функции, хуки/стейт

Для написания новых компонентов стоит использовать функциональный подход. Классы можно применять только в случае очень крайней необходимости, например - ErrorBoundary компонент.

## props

Старайтесь делать API ваших компонентов максимально простым и расширяемым. Сведите к минимуму передачу сложных объектов
как prop, передавайте отдельные поля таких объектов отдельными пропсами.

Не передавайте лишних данных просто потому, что они пришли вместе с ответом от api.

Если ваш компонент стал принимать больше 10 разных пропсов - это повод задуматься о рефакторинге. Возможно, вы можете
использовать композицию из нескольких более простых компонентов.

## ErrorBoundaries

Ваше приложение **должно** содержать высоко расположенный компонент с реализацией `componentDidCatch` метода.

## Обращения к api

Ваши react-компоненты **не должны** содержать код вызовов апи. Для этого есть внешние функции.

## Бизнес-логика

Ваши компоненты **не должны** содержать в себе бизнес-логику. Ее лучше выносить в селекторы или просто отдельные
функции,
которые можно легко и просто тестировать.

## smart/dumb компоненты

**Рекомендуется** разделять компоненты, реализующие верстку, от компонентов, реализующих бизнес-логику.

Когда в одном коде появляется и сложная обработка действий пользователя, запуск экшенов и раскраска кнопки в зеленый
цвет
при некоторых условиях - такой компонент становится очень сложно поддерживать.

_Допускается_ привязывать к стору компоненты, содержащие верстку если они используют полученные из стора значения и
методы как есть.

## data-test-id

Для написания интеграционных и e2e тестов **рекомендуется** использовать `data-test-id` атрибуты компонентов.

## Создание компонентов в теле функционального компонента

Создание компонентов в render или в теле функционального компонента **запрещено**. 1 файл - 1 компонент. Так делать
нельзя:

```tsx
const Foo = ({ isFlag, otherProp1, otherProp2 }) => {
  const Test = () => <span>{otherProp1}</span>;
  const Test2 = () => <div>{otherProp2}</div>;

  return isFlag ? <Test /> : <Test2 />;
};
```

## Размеры компонентов

**Не рекомендуется** иметь компоненты более, чем на 200 строк кода.

_200 строк - эмпирически полученное число. Естественно, компоненты в 203 строки не несут в себе зла. Но все же, если вы
переходите за эту воображаемую границу - это повод задуматься о рефакторинге._

## Структура компонента

```tsx
import { ChangeEvent, useEffect } from 'react';

// Интерфейс/тип
interface Form {
  inputName?: string;
};

// Блок с переменными и константами, которые обязательно должны быть определены именно в рамках файла компонента.
const CONSTANT_VALUE = 'Hello';

// Динамический импорт компонентов
// ...code

const Foo = () => {
  // Блок с ref'ами
  const wrapRef = useRef<HTMLDivElement>(null);

  // Блок с вызовами хуков react
  const [value, setValue] = useState('');

  // Блок с вызовами кастомных хуков (например хук, содержащий в себе логику компонента)
  const customHook = useFoo();

  // Блок с вызовами хуков из других библиотек
  const form = useForm<Form>();

  // Функция события может быть вынесена в отдельный блок или написана inline  
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => setValue(e.target.value);

  // Блок вызова useEffect (всегда только перед return)
  useEffect(() => {
    console.log('useEffect()');
  }, []);

  // Рендер компонента
  return (
    <div ref={wrapRef}>
      <h1>Foo Component</h1>

      <input value={value} onChange={handleChange} />
      <input value={value} onChange={e => setValue(e.target.value)} />

      <input {...form.register('inputName')} />
    </div>
  );
};
```

## Разделение на логику и UI части компонента
Для уменьшения кол-ва строк и упрощения работы с компонентом весь код до функции рендера компонента стоит выносить в отдельный кастомный хук, поместив его рядом с компонентом с префиксом "use-".

## Strict-режим

В проектах **обязательно** использование [React.Strict](https://reactjs.org/docs/strict-mode.html).
